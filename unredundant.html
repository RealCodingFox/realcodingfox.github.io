<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Unredundant</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: url('Moon.jpg') no-repeat center center fixed;
      background-size: cover;
      font-family: 'Segoe UI', sans-serif;
      color: #fff;
    }
    .glass-container {
      backdrop-filter: blur(12px);
      background: rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 2rem;
      margin: 5vh auto;
      width: 80%;
      box-shadow: 0 0 40px rgba(0, 0, 0, 0.4);
    }
    input[type="file"], button {
      margin-bottom: 1rem;
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      cursor: pointer;
    }
    progress {
      width: 100%;
      height: 20px;
      margin-bottom: 1rem;
    }
    .log-box {
      background: rgba(0, 0, 0, 0.3);
      padding: 1rem;
      border-radius: 8px;
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 1rem;
    }
  </style>
</head>
<body>
  <div class="glass-container">
    <h1>Unredundant</h1>
    <input type="file" id="docxInput" accept=".docx" />
    <progress id="progressBar" value="0" max="100"></progress>
    <div id="logOutput" class="log-box"></div>
    <button id="downloadBtn">Download Corrected Doc</button>
  </div>

  <script type="module">
  import * as docx from "https://unpkg.com/docx@8.1.0/build/index.js";
  import JSZip from "https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm";

  const logBox = document.getElementById('logOutput');
  const progressBar = document.getElementById('progressBar');
  const downloadBtn = document.getElementById('downloadBtn');
  let correctedDoc;

  const log = (msg) => {
    const div = document.createElement('div');
    div.textContent = msg;
    logBox.appendChild(div);
    logBox.scrollTop = logBox.scrollHeight;
  };

  document.getElementById('docxInput').addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    log("Genesis.");
    const zip = await JSZip.loadAsync(await file.arrayBuffer());
    const xml = await zip.file("word/document.xml").async("string");

    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xml, "application/xml");

    const used = new Set();
    const children = [];
    const body = xmlDoc.getElementsByTagName("w:body")[0];
    const nodes = Array.from(body.childNodes);

    nodes.forEach((node, index) => {
      progressBar.value = Math.floor(((index + 1) / nodes.length) * 100);

      if (node.nodeName === "w:p") {
        const runs = [];
        const texts = node.getElementsByTagName("w:r");

        Array.from(texts).forEach(run => {
          const textNode = run.getElementsByTagName("w:t")[0];
          if (!textNode) return;

          const text = textNode.textContent.trim();
          const norm = text.toLowerCase().replace(/[^a-z0-9]/g, '');
          const isRedundant = used.has(norm);
          if (!isRedundant) {
            used.add(norm);
            log(`Fresh phrase: "${text}"`);
          } else {
            log(`Redundancy found: "${text}"`);
          }

          const props = run.getElementsByTagName("w:rPr")[0];
          const isBold = props?.getElementsByTagName("w:b").length > 0;
          const isItalic = props?.getElementsByTagName("w:i").length > 0;

          runs.push(new docx.TextRun({
            text: text + " ",
            bold: isBold,
            italics: isItalic,
            highlight: isRedundant ? "yellow" : undefined
          }));
        });

        if (runs.length > 0) {
          children.push(new docx.Paragraph({ children: runs }));
        }
      }

      if (node.nodeName === "w:tbl") {
        const docxRows = [];
        const rows = node.getElementsByTagName("w:tr");

        Array.from(rows).forEach(row => {
          const docxCells = [];
          const cells = row.getElementsByTagName("w:tc");

          Array.from(cells).forEach(cell => {
            const texts = cell.getElementsByTagName("w:t");
            const full = Array.from(texts).map(t => t.textContent.trim()).join(" ");
            const norm = full.toLowerCase().replace(/[^a-z0-9]/g, '');
            const isRedundant = used.has(norm);
            if (!isRedundant) {
              used.add(norm);
              log(`Fresh cell: "${full}"`);
            } else {
              log(`Redundant cell: "${full}"`);
            }

            const cellRun = new docx.TextRun({
              text: full,
              highlight: isRedundant ? "yellow" : undefined
            });

            const tcPr = cell.getElementsByTagName("w:tcPr")[0];
            let width = undefined;
            let fill = undefined;

            if (tcPr) {
              const tcW = tcPr.getElementsByTagName("w:tcW")[0];
              if (tcW) {
                width = parseInt(tcW.getAttribute("w:w"));
              }

              const shd = tcPr.getElementsByTagName("w:shd")[0];
              if (shd) {
                fill = shd.getAttribute("w:fill");
              }
            }

            const cellOptions = {
              children: [new docx.Paragraph({ children: [cellRun] })]
            };

            if (width) {
              cellOptions.width = {
                size: width,
                type: docx.WidthType.DXA
              };
            }

            if (fill) {
              cellOptions.shading = {
                fill: fill
              };
            }

            docxCells.push(new docx.TableCell(cellOptions));
          });

          docxRows.push(new docx.TableRow({ children: docxCells }));
        });

        children.push(new docx.Table({
          rows: docxRows,
          width: {
            size: 10000,
            type: docx.WidthType.DXA
          }
        }));
      }
    });

    correctedDoc = new docx.Document({
      sections: [{ children }]
    });

    log("Exodus.");
  });

  downloadBtn.addEventListener('click', async () => {
    if (!correctedDoc) return;
    const blob = await docx.Packer.toBlob(correctedDoc);
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = "corrected.docx";
    a.click();
  });
</script>
</body>
</html>
